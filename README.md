# project-7: Enterprise Kubernetes Infrastructure with GitOps

A production-ready, multi-stage Kubernetes infrastructure deployment system using Terraform, ArgoCD, and GitHub Actions. Features sophisticated bootstrap protection, VPC peering, and self-hosted GitHub runners.

## Architecture Overview

### Infrastructure Components

**Main Infrastructure (`terraform-main/`)**
- EKS Kubernetes cluster with private endpoints
- VPC with public/private subnets across dynamically configured AZs (controlled via tfvars)
- ArgoCD with GitHub SSO integration
- AWS Load Balancer Controller
- External DNS and ACM certificate management
- Monitoring stack (Prometheus, Grafana)
- External Secrets Operator (enables ArgoCD repository access and SSO initialization)

**Runner Infrastructure (`terraform-runner-infra/`)**
- Self-hosted GitHub runners in separate VPC
- VPC peering to main infrastructure
- Isolated networking for CI/CD operations

**GitOps Repository Structure**
```
├── environments/
│   └── dev/
│       ├── apps/
│       │   └── frontend/
│       │       └── application.yaml    # Frontend application definition
│       └── manifests/
│           └── frontend/
│               ├── infra-values.yaml   # Infrastructure values (Terraform managed)
│               ├── digest-values.yaml  # Image digest values (App repo managed)
│               └── app-values.yaml     # Application values (static)
└── reference_only/*                    # All environments (dev, staging, prod)
    ├── project/
    │   └── project-7.yaml              # ArgoCD Project (reference)
    └── app_of_apps.yaml                # App of Apps (reference)
```

The `reference_only/*` directory contains files for all environments that are created for documentation purposes only - the actual ArgoCD Project and App-of-Apps are deployed via Terraform Helm configuration.

## Prerequisites

### 1. AWS Infrastructure Prerequisites

Navigate to the `terraform-requirements` folder and run:
```bash
cd terraform-requirements
terraform init
terraform apply
```

This creates the foundational AWS resources. **Save the outputs:**
```
aws_iam_openid_connect_provider_github_arn = "arn:aws:iam::ACCOUNT:oidc-provider/token.actions.githubusercontent.com"
github_oidc_role_arn = "arn:aws:iam::ACCOUNT:role/PROJECT_NAME-role-for-manual-tf"
```

### 2. GitHub Personal Access Token

Create a fine-grained PAT at: https://github.com/settings/personal-access-tokens

**Required permissions for both application and GitOps repositories:**
- Actions (read/write)
- Contents (read/write)
- Pull requests (read/write)
- Secrets (read/write)
- Variables (read/write)
- Administration (read/write) (mainly for the github self-hosted runner)

### 3. GitHub Application for ArgoCD

1. Create new GitHub App: https://github.com/settings/apps/new
2. Configuration:
   - **Name:** Choose descriptive name
   - **Homepage URL:** Your GitOps repository URL
   - **Webhook:** Uncheck "Active"
   - **Repository permissions:** Contents (read)
   - **Installation:** Only on this account
3. After creation:
   - Generate a Client secret
   - Generate and download private key (at the bottom)
   - Note the App ID from the app settings page
4. Install the app: (it's available in the same window you were just at)
   - Go to https://github.com/settings/installations
   - Install app and give it permissions over both application and GitOps repositories
   - Note the Installation ID from the URL

### 4. GitHub OAuth Application for ArgoCD SSO

1. Go to your GitHub organization: https://github.com/organizations/YOUR_ORG/settings/applications
2. Create OAuth App:
   - **Application name:** Choose descriptive name
   - **Homepage URL:** Must match your Terraform configuration
   - **Authorization callback URL:** Homepage URL + `/api/dex/callback`

**Important:** The ArgoCD URL is automatically generated by Terraform using these variables:
- Format: `https://{argocd_base_domain_name}-{environment}.{subdomain_name}.{domain_name}`
- Example: `https://argocd-dev.project-7.projects-devops.cfd`
- Configure these in your `terraform.tfvars`:
  ```hcl
  argocd_base_domain_name = "argocd"
  environment = "dev" 
  subdomain_name = "project-7"
  domain_name = "projects-devops.cfd"
  ```

You cannot choose the URL arbitrarily - it must match your Terraform domain configuration.

### 5. GitHub Organization Teams

Create two teams in your GitHub organization:
- **developers:** Read-only access to ArgoCD
- **devops:** Full admin access to ArgoCD

Update their names in the tfvars (`github_admin_team`, `github_readonly_team`)

### 6. Repository Secrets Configuration

#### Terraform Repository Secrets
Set these in your **project-7-tf** repository settings:

**Environment-Independent Secrets:**
```
PROVIDER_GITHUB_ARN = arn:aws:iam::ACCOUNT:oidc-provider/token.actions.githubusercontent.com
AWS_ROLE_TO_ASSUME = arn:aws:iam::ACCOUNT:role/project-7-dev-initial-role-for-tf
TOKEN_GITHUB = github_pat_YOUR_TOKEN
```

**Environment-Specific Secrets:**
For each environment (dev/staging/prod), create:
```
ARGOCD_APP_ID_TF_DEV = YOUR_GITHUB_APP_ID
ARGOCD_INSTALLATION_ID_TF_DEV = YOUR_INSTALLATION_ID
ARGOCD_PRIVATE_KEY_TF_DEV = BASE64_ENCODED_PRIVATE_KEY
OAUTH_GITHUB_CLIENT_ID_TF_DEV = YOUR_OAUTH_CLIENT_ID
OAUTH_GITHUB_CLIENT_SECRET_TF_DEV = YOUR_OAUTH_CLIENT_SECRET
```

**Note:** For the private key, base64 encode the entire key content (including BEGIN/END lines) as a single line. Ensure no extra spaces or newlines are added before or after the encoded content when pasting into the GitHub secret field.

Encode from a Linux machine:
```bash
cat your-private-key.pem | base64 -w 0 > encoded.txt
```

#### Repository Variables
Set these in your **project-7-tf** repository:
```
AWS_REGION = us-east-1
```

## Deployment Workflow

### Bootstrap Process

The system uses a sophisticated 4-stage bootstrap process to handle complex dependencies:

**Stage 1: Core Infrastructure**
- VPC and EKS cluster deployment
- Targets: `module.vpc`, `module.eks`

**Stage 2: Runner Infrastructure** 
- GitHub self-hosted runners
- Full terraform-runner-infra deployment

**Stage 3: Networking & Security**
- VPC peering between infrastructures
- Security group configurations with bootstrap protection
- Targets: `module.vpc_peering`, `module.security_groups`

**Stage 4: Complete Deployment**
- All remaining AWS resources and modules
- Full ArgoCD and application deployment
- Runs on self-hosted runners (private EKS access)

### Workflow Types

**Initialization Workflow (`terraform-initialization.yml`)**
- Multi-stage bootstrap deployment
- Runs on GitHub-hosted runners
- Handles initial deployment dependencies

**Main Deployment Workflow (`deploy.yml`)**
- Complete infrastructure management
- Runs on self-hosted runners
- Supports GitOps operations

## Deployment Instructions

### First Deployment

1. **Initial Bootstrap**
   ```
   Workflow: terraform-initialization
   Environment: dev
   Action: plan-and-apply  
   First Run: true
   Plan Full Runs: false
   ```

2. **Verify Infrastructure**
   - Check EKS cluster status
   - Verify self-hosted runners are online
   - Application repository automatically triggers build and ECR push

3. **Access ArgoCD**
   - URL: Automatically generated as `https://{argocd_base_domain_name}-{environment}.{subdomain_name}.{domain_name}`
   - For default config: `https://argocd-dev.project-7.projects-devops.cfd`
   - Login with GitHub SSO (authorize the application on first login)

### Subsequent Updates

**Infrastructure Changes via Main Workflow:**
```
Workflow: deploy
Environment: dev
Action: plan (or apply)
GitOps Mode: update-infra (or bootstrap for full changes)
```

**Application Updates:**
- Handled automatically via GitOps
- ArgoCD monitors application repository
- Automatic sync on changes

### Manual Terraform Commands (Alternative)

1. **Initialize Terraform:**
   ```bash
   cd terraform-main/main
   terraform init
   ```

2. **Plan and review changes:**
   ```bash
   terraform plan -var-file="../environments/dev/terraform.tfvars"
   ```

3. **Bootstrap deployment:**
   ```bash
   terraform apply --auto-approve \
     --var-file="../environments/dev/terraform.tfvars" \
     --var="auto_merge_pr=true" \
     --var="bootstrap_mode=true"
   ```

4. **Subsequent updates:**
   ```bash
   terraform apply --auto-approve \
     --var-file="../environments/dev/terraform.tfvars" \
     --var="bootstrap_mode=false" \
     --var="update_apps=true"
   ```

## Key Features

### Bootstrap Protection
- Handles "chicken-and-egg" dependency problems
- Graceful planning when remote state doesn't exist
- Conditional resource creation based on deployment stage

### GitOps Integration
- ArgoCD with GitHub SSO
- Multi-source applications (charts + values)
- Automatic PR creation and merging for both:
  - Infrastructure changes (Terraform updates to GitOps values)
  - Application changes (Application repository updates to digest values)
- Application and infrastructure separation

### Security
- Private EKS endpoints
- VPC peering for runner access
- OIDC-based authentication
- Least-privilege IAM roles

### Networking
- Multi-AZ deployment (number of AZs dynamically configured via tfvars)
- NAT gateway configurations
- Application Load Balancer with SSL
- External DNS integration

## Repository Structure

```
├── requirements-tf/             # Prerequisites setup
├── terraform-main/
│   ├── main/                    # Main configuration
│   ├── modules/                 # Reusable modules
│   └── environments/           # Environment-specific configs
├── terraform-runner-infra/
│   ├── main/                    # Runner configuration
│   ├── modules/                 # Runner modules  
│   └── environments/           # Runner environment configs
├── .github/workflows/
│   ├── terraform-initialization.yml
│   └── deploy.yml
└── scripts/                     # Utility scripts
```

## Workflow Variables Summary

- **auto_merge_pr:** Controls automatic PR merging in GitOps repository (triggers a GitOps repo workflow to merge)
- **bootstrap_mode:** Creates yamls in the GitOps Repository (Creates a PR). ArgoCD project and app-of-apps yaml are for reference only (they are deployed using helm). Applications and their value files are also created. This mode also triggers the Application Repository's workflow that builds the app, pushes to ECR, creates a GitOps PR to update the digest, and triggers a GitOps Repo workflow to merge it.
- **update_apps:** Updates infrastructure values in GitOps repository only (Creates a PR)
- **first_run:** Handles initial deployment bootstrap protection

## Advanced Configuration

### NAT Gateway Modes
- `single`: Single NAT gateway (cost-optimized)
- `real`: Multiple NAT gateways (high availability)

### Environment Scaling
- Configurable node groups
- Auto-scaling based on workload
- Resource limits and requests

### Monitoring
- Prometheus metrics collection
- Grafana dashboards
- ArgoCD operational metrics

## Security Considerations

- All EKS endpoints are private
- VPC peering provides secure runner access
- OIDC authentication eliminates long-lived credentials  
- Least-privilege IAM policies
- Encrypted state storage
- Network segmentation

## Common Issues and Solutions

### ArgoCD Access Issues
- Verify DNS propagation (can take 10-20 minutes)
- Check ALB target health
- Ensure your IP is whitelisted in `argocd_allowed_cidr_blocks`

### GitHub Authentication
- Ensure GitHub App is installed on both repositories
- Verify OAuth application callback URL matches ArgoCD domain
- Check organization team membership for proper RBAC access

### Workflow Triggers
- Verify all environment-specific secrets exist
- Check GitHub Actions logs for API permission errors
- Ensure workflows have proper permissions configured
